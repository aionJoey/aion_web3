<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/accounts.js | aion-web3</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="web3-compatible api for working with aion"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="aion-web3"><meta property="twitter:description" content="web3-compatible api for working with aion"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/aionnetwork/aion_web3.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/accounts.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">let parallel = require(&apos;async/parallel&apos;)
let get = require(&apos;lodash/get&apos;)
let uuidv4 = require(&apos;uuid/v4&apos;)
let {isEmpty, isFunction, isObject, find} = require(&apos;underscore&apos;)
let rlp = require(&apos;rlp&apos;)
let {assignExtend} = require(&apos;./extend&apos;)
let {assignProvider} = require(&apos;./providers&apos;)
let {
  isPrivateKey,
  createA0Address,
  createA0AddressString,
  isAccountAddress,
  createPrivateKey
} = require(&apos;./lib/accounts&apos;)
let {hexToNumber} = require(&apos;./utils&apos;)
let crypto = require(&apos;./lib/crypto&apos;)
let {keccak256, nacl, scrypt} = crypto
let {validateTransaction} = require(&apos;./lib/transactions&apos;)
let {
  toBuffer,
  equalBuffers,
  randomHexBuffer,
  removeLeadingZeroX
} = require(&apos;./lib/formats&apos;)
let values = require(&apos;./lib/values&apos;)
let Wallet = require(&apos;./wallet&apos;)

let methods = [
  {
    name: &apos;getId&apos;,
    call: &apos;net_version&apos;,
    params: 0,
    outputFormatter: hexToNumber
  },
  {
    name: &apos;getGasPrice&apos;,
    call: &apos;eth_gasPrice&apos;,
    params: 0
  },
  {
    name: &apos;getTransactionCount&apos;,
    call: &apos;eth_getTransactionCount&apos;,
    params: 2,
    inputFormatter: [
      function(address) {
        if (isAccountAddress(address) === true) {
          return address
        } else {
          throw new Error(
            &apos;Address &apos; +
              address +
              &apos; is not a valid address to get the &quot;transactionCount&quot;.&apos;
          )
        }
      },
      function() {
        return &apos;latest&apos;
      }
    ]
  }
]

let signTransactionDefaults = {
  chainId: values.nat.one,
  to: values.zeroX,
  data: values.zeroX,
  value: values.zeroX
}

function fromNat(val) {
  if (val === values.nat.zero) {
    return values.zeroX
  }

  if (val.length % 2 === 0) {
    return val
  }

  return values.nat.zero + removeLeadingZeroX(val)
}

/**
 * Account constructor
 * @param {object} options
 * @param {object} options.accounts
 * @param {string} options.address
 * @param {buffer} options.entropy
 * @param {buffer} options.privateKey
 * @returns {object}
 */
function Account({accounts, address, entropy, privateKey}) {
  if (isEmpty(accounts) === true) {
    throw new Error(
      &apos;an accounts instance is necessary to instantiate an account&apos;
    )
  }

  if (isEmpty(address) == false &amp;&amp; isAccountAddress(address) === false) {
    throw new Error(&apos;an invalid address was passed to Account&apos;)
  }

  // held internally to access accounts functions
  this._accounts = accounts

  // key generation entropy
  let ent =
    (isEmpty(entropy) === false &amp;&amp; toBuffer(entropy)) || randomHexBuffer()

  this.privateKey =
    (isEmpty(privateKey) === false &amp;&amp; toBuffer(privateKey)) ||
    createPrivateKey(ent)

  let kp = nacl.sign.keyPair.fromSeed(this.privateKey)

  this._nacl = {
    publicKey: toBuffer(kp.publicKey),
    secretKey: toBuffer(kp.secretKey)
  }

  // held so we don&apos;t have to recompute
  this._addressBuffer = null

  // 0xAO address
  this.address = address || null

  if (isEmpty(this.address) === true &amp;&amp; isEmpty(this.privateKey) === false) {
    this._addressBuffer = createA0Address(this.privateKey)
    this.address = createA0AddressString(this._addressBuffer)
  }
}

Account.prototype.signTransaction = function(tx, done) {
  let {privateKey} = this
  return this._accounts.signTransaction(tx, privateKey, done)
}

Account.prototype.sign = function(message) {
  let {privateKey} = this
  return this._accounts.sign(message, privateKey)
}

Account.prototype.encrypt = function(password, options) {
  let {privateKey} = this
  return this._accounts.encrypt(privateKey, password, options)
}

/**
 * Accounts constructor
 */
function Accounts(provider, providerOpts) {
  assignProvider(this, {provider, providerOpts})
  assignExtend(this, {methods})
  this.wallet = new Wallet(this)
}

/*

Accounts instance members

*/

/**
 * Create Account using randomized data
 * @param {object} entropy hex buffer or string
 * @return {object}
 */
Accounts.prototype.create = function(entropy) {
  let accounts = this
  let account = new Account({accounts, entropy})

  // it could automatically add into the wallet
  // this.wallet.add(account)
  return account
}

Accounts.prototype._findAccountByPk = function(privateKey) {
  return find(this.wallet, account =&gt; {
    let privKey = get(account, &apos;privateKey&apos;)
    if (isEmpty(privKey) === true) {
      return false
    }
    return equalBuffers(privateKey, privKey)
  })
}

/**
 * Get an account by providing a private key
 * @param {object} privateKey hex buffer or string
 * @return {object} [description]
 */
Accounts.prototype.privateKeyToAccount = function(privateKey) {
  let accounts = this
  let account =
    this._findAccountByPk(privateKey) || new Account({accounts, privateKey})
  // this.wallet.add(account)
  return account
}

Accounts.prototype.signTransaction = function(tx, privateKey, done) {
  function signTransactionFailed(err) {
    if (isFunction(done) === true) {
      return done(err)
    }
    return Promise.reject(err)
  }

  if (isEmpty(tx) === true) {
    return signTransactionFailed(new Error(&apos;no transaction was provided&apos;))
  }

  if (isPrivateKey(privateKey) === false) {
    return signTransactionFailed(new Error(&apos;the private key was invalid&apos;))
  }

  let steps = {}
  let account =
    this._findAccountByPk(privateKey) || this.privateKeyToAccount(privateKey)
  let transaction = Object.assign({}, signTransactionDefaults, tx)
  let {_nacl} = account

  if (isEmpty(transaction.from) === true) {
    transaction.from = account.address
  }

  if (isEmpty(transaction.chainId) === true) {
    // get chain id
    steps.chainId = done =&gt; this.getId(done)
  }

  if (isEmpty(transaction.gasPrice) === true) {
    // get gas price
    steps.gasPrice = done =&gt; this.getGasPrice(done)
  }

  if (isEmpty(transaction.nonce) === true) {
    // get transaction count to use as nonce
    steps.nonce = done =&gt;
      this.getTransactionCount(account.address, &apos;latest&apos;, done)
  }

  function sign(res) {
    transaction = Object.assign({}, transaction, res)
    let [valid, error] = validateTransaction(transaction)

    if (valid === false) {
      throw error
    }

    let {
      to,
      // from,
      data,
      value,
      gas,
      // gasLimit,
      gasPrice,
      nonce,
      chainId
    } = transaction

    let encoded = rlp.encode([
      fromNat(nonce),
      fromNat(gasPrice),
      fromNat(gas),
      to.toLowerCase(),
      fromNat(value),
      data,
      fromNat(chainId),
      values.zeroX,
      values.zeroX
    ])

    let messageHash = keccak256(encoded)
    let signature = toBuffer(nacl.sign(toBuffer(messageHash), _nacl.secretKey))
    let rawTx = rlp.decode(encoded).concat(signature)
    let rawTransaction = rlp.encode(rawTx)

    return {
      messageHash,
      signature,
      rawTransaction
    }
  }

  // callback
  if (isFunction(done) === true) {
    return parallel(steps, (err, res) =&gt; {
      if (isEmpty(err) === false) {
        return done(err)
      }

      try {
        done(null, sign(res))
      } catch (e) {
        done(e)
      }
    })
  }

  // Promise
  return new Promise((resolve, reject) =&gt; {
    parallel(steps, (err, res) =&gt; {
      if (isEmpty(err) === false) {
        return reject(err)
      }

      try {
        resolve(sign(res))
      } catch (e) {
        reject(e)
      }
    })
  })
}

Accounts.prototype.recoverTransaction = function(rawTx) {
  throw new Error(`recoverTransaction not yet implemented ${rawTx}`)
}

/**
 * Hashed aion signed message with preamble
 * @param {string} message
 * @return {buffer} keccak256 hash
 */
Accounts.prototype.hashMessage = function(message) {
  let messageBuffer = toBuffer(message)
  let len = messageBuffer.length
  let preamble = `\x19Aion Signed Message:\n${len}`
  let preambleBuffer = toBuffer(preamble)
  return keccak256(Buffer.concat([preambleBuffer, messageBuffer]))
}

/**
 * Sign the message with account address and message signature
 * @param {string} message
 * @param {buffer} privateKey
 * @return {object} contains message, messageHash, signature
 */
Accounts.prototype.sign = function(message, privateKey) {
  let {address, _nacl} =
    this._findAccountByPk(privateKey) || this.privateKeyToAccount(privateKey)
  let messageHash = this.hashMessage(message)
  let messageSignature = nacl.sign(toBuffer(messageHash), _nacl.secretKey)
  let signature = Buffer.concat([toBuffer(address), messageSignature]).toString(
    &apos;hex&apos;
  )
  return {
    message,
    messageHash,
    signature
  }
}

/**
 * The aion address is the first 64 bytes of the signature
 * @param {object|string} message
 * @param {string|buffer} signature
 * @return {string} the signing address
 */
Accounts.prototype.recover = function(message, signature) {
  return toBuffer(signature || message.signature)
    .slice(0, 32)
    .toString(&apos;hex&apos;)
}

/**
 * Encrypt an account to keystore v3 format
 * @param {buffer} privateKey
 * @param {string|Buffer} password
 * @param {object} options
 * @param {string} options.kdf pbkdf2 or scrypt
 * @param {buffer} [options.salt]
 * @param {buffer} [options.iv] initialization vector
 * @param {number} [options.dklen] key length bytes
 * @param {number} [options.c] pbkdf2 c variable
 * @param {number} [options.n] scrypt n variable
 * @param {number} [options.r] scrypt r variable
 * @param {number} [options.p] scrypt p variable
 * @param {function} [options.scryptProgress] arguments (current, total, percent)
 * @param {number} [options.cipher] algorithm
 * @param {number} [options.uuid] random bytes for id
 * @return {object} [description]
 */
Accounts.prototype.encrypt = function(privateKey, password, options = {}) {
  if (isEmpty(privateKey) === true) {
    throw new Error(`missing private key`)
  }

  if (isEmpty(password) === true) {
    throw new Error(`missing password`)
  }

  let account = this.privateKeyToAccount(privateKey)
  let address = removeLeadingZeroX(account.address.toLowerCase())

  let {
    salt = randomHexBuffer(values.crypto.saltLength),
    iv = randomHexBuffer(values.crypto.ivLength),
    kdf = values.crypto.kdf,
    dklen = values.crypto.dklen
  } = options

  iv = toBuffer(iv)
  let pwBuf = toBuffer(password)
  let saltBuf = toBuffer(salt)
  salt = salt.toString(&apos;hex&apos;)

  let derivedKey
  let kdfparams = {dklen, salt}

  if (kdf === &apos;pbkdf2&apos;) {
    let {c = values.crypto.pbkdf2.c} = options
    let digest = values.crypto.pbkdf2.digest

    kdfparams.c = c

    // this values doesn&apos;t do anything
    // it just goes into the return object kdfparams
    kdfparams.prf = values.crypto.pbkdf2.prf

    derivedKey = crypto.node.pbkdf2Sync(pwBuf, saltBuf, c, dklen, digest)
  }

  if (kdf === &apos;scrypt&apos;) {
    let {
      n = values.crypto.scrypt.n,
      r = values.crypto.scrypt.r,
      p = values.crypto.scrypt.p
    } = options
    kdfparams.n = n
    kdfparams.r = r
    kdfparams.p = p
    let scryptArgs = [pwBuf, saltBuf, n, r, p, dklen]
    if (isFunction(options.scryptProgress) === true) {
      scryptArgs.push(options.scryptProgress)
    }
    derivedKey = scrypt.apply(null, scryptArgs)
  }

  if (isEmpty(derivedKey) === true) {
    throw new Error(&apos;Unsupported kdf&apos;)
  }

  let algorithm = options.cipher || values.crypto.cipherIvAlgorithm
  let keyStart = derivedKey.slice(0, 16)
  let keyEnd = derivedKey.slice(16, 32)
  let cipher = crypto.node.createCipheriv(algorithm, keyStart, iv)

  if (isEmpty(cipher) === true) {
    throw new Error(&apos;Unsupported cipher&apos;)
  }

  let cipherBuf = Buffer.concat([cipher.update(privateKey), cipher.final()])
  let ciphertext = cipherBuf.toString(&apos;hex&apos;)
  let mac = keccak256(Buffer.concat([keyEnd, cipherBuf])).toString(&apos;hex&apos;)
  let version = 3
  let {uuid = crypto.node.randomBytes(values.crypto.uuidRandomBytes)} = options
  let id = uuidv4({random: uuid})
  let cipherparams = {iv: iv.toString(&apos;hex&apos;)}

  return {
    version,
    id,
    address,
    crypto: {
      ciphertext,
      cipherparams,
      cipher: algorithm,
      kdf,
      kdfparams,
      mac
    }
  }
}

Accounts.prototype.decrypt = function(ksv3, password, nonStrict) {
  if (isEmpty(password) === true) {
    throw new Error(&apos;No password given.&apos;)
  }

  let keystore =
    isObject(ksv3) === true
      ? ksv3
      : JSON.parse(nonStrict === true ? ksv3.toLowerCase() : ksv3)

  if (keystore.version !== 3) {
    throw new Error(&apos;not a valid keystore v3 object&apos;)
  }

  let derivedKey
  let {kdf, cipherparams} = keystore.crypto
  let algorithm = keystore.crypto.cipher
  let {kdfparams, ciphertext} = keystore.crypto
  let {salt, dklen} = kdfparams
  let pwBuf = toBuffer(password)
  let saltBuf = toBuffer(salt)
  let cipherBuf = toBuffer(ciphertext)

  if (kdf === &apos;scrypt&apos;) {
    // scrypt-specific params
    let {n, r, p} = kdfparams
    derivedKey = crypto.scrypt(pwBuf, saltBuf, n, r, p, dklen)
  }

  if (kdf === &apos;pbkdf2&apos;) {
    // pbkdf2-specific params
    let {c} = kdfparams
    let digest = values.crypto.pbkdf2.digest
    derivedKey = crypto.node.pbkdf2Sync(pwBuf, saltBuf, c, dklen, digest)
  }

  if (isEmpty(derivedKey) === true) {
    throw new Error(&apos;Unsupported key derivation scheme&apos;)
  }

  let keyStart = derivedKey.slice(0, 16)
  let keyEnd = derivedKey.slice(16, 32)
  let mac = keccak256(Buffer.concat([keyEnd, cipherBuf]))

  if (mac !== keystore.crypto.mac) {
    throw new Error(`
      The mac hash failed. This indicates password could be wrong.
      keystore mac: ${keystore.crypto.mac}
      calculated mac: ${mac}
    `)
  }

  // initialization vector
  let iv = toBuffer(cipherparams.iv)
  let decipher = crypto.node.createDecipheriv(algorithm, keyStart, iv)
  let privateKey = Buffer.concat([decipher.update(cipherBuf), decipher.final()])

  return this.privateKeyToAccount(privateKey)
}

module.exports = Accounts
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
