<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/utils.js | aion-web3</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="web3-compatible api for working with aion"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="aion-web3"><meta property="twitter:description" content="web3-compatible api for working with aion"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/aionnetwork/aion_web3.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/utils.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * @module utils
 */

let {Buffer} = require(&apos;safe-buffer&apos;)
let BN = require(&apos;bn.js&apos;)

let numberToBn = require(&apos;number-to-bn&apos;)
let randomhex = require(&apos;randomhex&apos;)
let utf8 = require(&apos;utf8&apos;)

let _ = require(&apos;underscore&apos;)

let {
  isEmpty,
  isObject,
  isString,
  isNumber,
  isEqual,
  isArray,
  isBoolean,
  each
} = _

let get = require(&apos;lodash/get&apos;)
let accounts = require(&apos;./lib/accounts&apos;)
let values = require(&apos;./lib/values&apos;)
let patterns = require(&apos;./lib/patterns&apos;)
let crypto = require(&apos;./lib/crypto&apos;)
let {
  removeLeadingZeroX,
  prependZeroX,
  startsWithZeroX,
  copyString
} = require(&apos;./lib/formats&apos;)

/**
 * Generate random hex values of a certain length
 * @param {number} size how many bytes
 * @return {string} randomly generated hex value starting with &apos;0x&apos;
 */
let randomHex = size =&gt; randomhex(size)

/**
 *
 * @member _
 * @type {function}
 */
// utils._ = _

/**
 * Constructor for bn.js
 *
 * It would be the same as `require(&apos;bn.js&apos;)`
 *
 * @constructor BN
 * @member BN
 */
// utils.BN = BN

/**
 * Convert number to BN
 */
let toBN = val =&gt; numberToBn(val)

/**
 * Get the constructor of whatever is passed in
 * @access private
 * @param {object} obj
 * @returns {string} constructor name
 */
let getConstructor = val =&gt; get(val, &apos;constructor.name&apos;)

/**
 * BN.isBN
 * @param {object} val
 * @returns {boolean}
 */
let isBN = val =&gt; BN.isBN(val)

/**
 * Is it a `BigNumber` or not?
 * @param {object} obj
 * @return {boolean}
 */
let isBigNumber = obj =&gt; getConstructor(obj) === &apos;BigNumber&apos;

/**
 * Checks if a value is a hex value
 *
 * 0x number expressions return false but &apos;0x&apos; string expressions true
 *
 * @param {string} val
 * @return {boolean}
 */
let isHex = val =&gt;
  (isString(val) === true || isNumber(val) === true) &amp;&amp;
  patterns.hex.test(val) === true

/**
 * Checks if a value is hex starting with &apos;0x&apos;
 * @param {string} val
 * @return {boolean}
 */
let isHexStrict = val =&gt;
  (isString(val) === true || isNumber(val) === true) &amp;&amp;
  patterns.hexStrict.test(val) === true

/**
 * Reduce function for hexToBytes. It splits by each two characters.
 * e.g. [&apos;ff&apos;, &apos;aa&apos;, &apos;f5&apos;, &apos;55&apos;]
 * @private
 * @return {array} array of hex bytes
 */
function hexToBytesReduction(acm, item, index, arr) {
  if (index % 2 === 0 &amp;&amp; index &lt;= arr.length - 2) {
    acm.push(item + arr[index + 1])
  }

  return acm
}

/**
 * Convert a hex string to a byte array
 *
 * @param {string|number|BN} hex
 * @return {array} the byte array
 */
function hexToBytes(val) {
  if (
    typeof val === &apos;string&apos; &amp;&amp;
    val.length % 2 !== 0 &amp;&amp;
    isHexStrict(val) === false
  ) {
    throw new Error(&apos;utils.hexToBytes requires a valid hex string&apos;)
  }

  let op

  if (typeof val === &apos;number&apos;) {
    op = toBN(val).toString(&apos;hex&apos;)
  }

  if (isBN(val) === true || isBigNumber(val) === true) {
    op = val.toString(&apos;hex&apos;)
  }

  if (typeof val === &apos;string&apos;) {
    op = copyString(val)
  }

  return removeLeadingZeroX(op)
    .split(&apos;&apos;)
    .reduce(hexToBytesReduction, [])
    .map(item =&gt; parseInt(item, 16))
}

function createPadder(direction) {
  return function createPadderInternal(val, length = 1, sign = &apos;0&apos;) {
    let padding = &apos;&apos;
    let isHex =
      typeof val === &apos;number&apos; ||
      startsWithZeroX(val) === true ||
      isBN(val) === true ||
      isBigNumber(val) === true
    let offset = isHex === true ? 2 : 0
    let valLen =
      isHex === true ? toBN(val).toString(&apos;hex&apos;).length + 2 : val.length
    let iterations = length - valLen + offset
    for (let i = 0; i &lt; iterations; i += 1) {
      padding += sign
    }

    let op = &apos;&apos;

    if (isHex === true) {
      op = removeLeadingZeroX(toBN(val).toString(&apos;hex&apos;))
    }

    if (isHex === false &amp;&amp; typeof val === &apos;string&apos;) {
      op = copyString(val)
    }

    if (direction === &apos;left&apos;) {
      op = `${padding}${op}`
    }

    if (direction === &apos;right&apos;) {
      op = `${op}${padding}`
    }

    if (isHex === true) {
      op = prependZeroX(op)
    }

    return op
  }
}

/**
 * Put padding to the left. The default padding sign is &apos;0&apos;
 * @param {string|number|BN|BigNumber} val
 * @param {number} length how many of the pad sign
 * @param {string} sign
 */
let padLeft = createPadder(&apos;left&apos;)

/**
 * Alias to padLeft
 */
let leftPad = padLeft

/**
 * Put padding to the right. The default padding sign is &apos;0&apos;
 * @param {string|number|BN|BigNumber} val
 * @param {number} quantity how many of the pad sign
 * @param {string} sign
 */
let padRight = createPadder(&apos;right&apos;)

/**
 * Alias to padRight
 */
let rightPad = padRight

/**
 * Convert array of bytes into hex string with 0x prepended
 * @param {array} val bytes
 * @return {string}
 */
let bytesToHex = val =&gt;
  prependZeroX(
    val
      .map(item =&gt; {
        let op = item.toString(16)
        if (op.length === 1) {
          // zero pad
          op = `0${op}`
        }
        return op
      })
      .join(&apos;&apos;)
  )

/**
 * Compute SHA3 256 length hash a.k.a. keccak256
 *
 * Prepends &apos;0x&apos; string to the result
 *
 * @param {string|array} val
 * @return {string} keccak256 hash
 */
function sha3(val) {
  // our keccak256 implementation or ethereum web3 don&apos;t accept these values
  if (
    isEmpty(val) === true ||
    // not having slice meaning it&apos;s not an array-like thing
    (typeof val !== &apos;string&apos; &amp;&amp;
      get(val, &apos;slice&apos;) === undefined &amp;&amp;
      isBN(val) === false)
  ) {
    throw new Error(`utils.sha3 invalid value: &quot;${val}&quot;`)
  }

  let isSha3Null = false

  // there&apos;s a list of things ethereum web3 returns null for so we do too
  each(values.sha3.nulls, item =&gt; {
    if (isEqual(item, val) === true) {
      isSha3Null = true
    }
  })

  // ethereum web3 returns null
  if (isSha3Null === true) {
    return null
  }

  let op

  if (typeof val === &apos;string&apos;) {
    // copy the string
    op = copyString(val)

    if (startsWithZeroX(op) === true) {
      // the user passed in a string like &apos;0xdccd2e7f400ab38e&apos;
      op = hexToBytes(op)
    }
  }

  if (isBN(val) === true) {
    op = val.toString()
  }

  op = crypto.keccak256(op).toString(&apos;hex&apos;)

  if (op === values.sha3.nullHex) {
    return null
  }

  return `0x${op}`
}

/**
 * Alias to utils.sha3
 * @param {string|array} val
 * @return {string} keccak256 hash
 */
// utils.keccak256 = sha3

/**
 * True if valid aion account address
 * @param {string} val
 * @return {boolean}
 */
let isAddress = val =&gt; accounts.isAccountAddress(val)

/**
 * Returns true if the address checksum calculates correctly
 * @param {string} val
 * @return {boolean} [description]
 */
function checkAddressChecksum(val) {
  if (accounts.isAccountAddress(val) === false) {
    throw new Error(`not a valid aion address: ${val}`)
  }

  return accounts.isValidChecksumAddress(val)
}

function utf8ToHex(val) {
  let op = utf8.encode(val)
  let hex = &apos;&apos;
  let code
  let codeString

  op = op.replace(patterns.utf8Null, &apos;&apos;)
  op = op
    .split(&apos;&apos;)
    .reverse()
    .join(&apos;&apos;)
  op = op.replace(patterns.utf8Null, &apos;&apos;)
  op = op
    .split(&apos;&apos;)
    .reverse()
    .join(&apos;&apos;)

  for (let i = 0; i &lt; op.length; i++) {
    code = op.charCodeAt(i)
    codeString = code.toString(16)
    hex += codeString.length &lt; 2 ? &apos;0&apos; + codeString : codeString
  }

  return &apos;0x&apos; + hex
}

function numberToHex(val) {
  if (val === undefined || val === null) {
    // should this warn? if the user thinks its a number but its not
    // it could cause other problems
    // console.warn(&apos;numberToHex, undefined or null&apos;, val)
    return val
  }

  if (isFinite(val) === false &amp;&amp; isHexStrict(val) === false) {
    throw new Error(&apos;numberToHex expecting number and got something else&apos;)
  }

  let number = numberToBn(val)
  let result = number.toString(16)
  return number.lt(new BN(0)) ? &apos;-0x&apos; + result.substring(1) : &apos;0x&apos; + result
}

/**
 * It&apos;s used internally to convert addresses, booleans, objects, strings,
 * and numbers into hex for solidity sha3.
 * @param {object} val
 * @param {string} [returnType]
 * @return {string}
 */
function toHex(val, returnType) {
  let {maxIntSize, hex, zeroX} = values
  let {zero, one} = hex

  if (isAddress(val) === true) {
    return returnType
      ? &apos;address&apos;
      : zeroX + removeLeadingZeroX(val.toLowerCase())
  }

  if (isBoolean(val) === true) {
    return returnType ? &apos;bool&apos; : val ? one : zero
  }

  if (
    isObject(val) === true &amp;&amp;
    isBigNumber(val) === false &amp;&amp;
    isBN(val) === false
  ) {
    return returnType ? &apos;string&apos; : utf8ToHex(JSON.stringify(val))
  }

  // if its a negative number, pass it through numberToHex
  if (isString(val) === true) {
    if (patterns.zeroXNegative.test(val) === true) {
      return returnType ? `int${maxIntSize}` : numberToHex(val)
    }

    if (startsWithZeroX(val) === true) {
      return returnType ? &apos;bytes&apos; : val
    }

    if (isFinite(val) === false) {
      return returnType ? &apos;string&apos; : utf8ToHex(val)
    }
  }

  if (isEmpty(returnType) === false) {
    if (val &lt; 0) {
      return `int${maxIntSize}`
    }

    return `uint${maxIntSize}`
  }

  return numberToHex(val)
}

function elementaryName(name) {
  if (name.startsWith(&apos;int[&apos;) === true) {
    // for example appends &apos;[45]&apos;
    return &apos;int128&apos; + name.slice(3)
  }
  if (name === &apos;int&apos;) {
    return &apos;int128&apos;
  }
  if (name.startsWith(&apos;uint[&apos;) === true) {
    return &apos;uint128&apos; + name.slice(4)
  }
  if (name === &apos;uint&apos;) {
    return &apos;uint128&apos;
  }
  if (name.startsWith(&apos;fixed[&apos;) === true) {
    return &apos;fixed128x128&apos; + name.slice(5)
  }
  if (name === &apos;fixed&apos;) {
    return &apos;fixed128x128&apos;
  }
  if (name.startsWith(&apos;ufixed[&apos;) === true) {
    return &apos;ufixed128x128&apos; + name.slice(6)
  }
  if (name === &apos;ufixed&apos;) {
    return &apos;ufixed128x128&apos;
  }
  return name
}

function parseNumber(val) {
  let type = typeof val
  if (type === &apos;string&apos;) {
    if (isHexStrict(val) === true) {
      return new BN(removeLeadingZeroX(val), 16)
    }
    return new BN(val, 10)
  }
  if (type === &apos;number&apos;) {
    return new BN(val)
  }
  if (isBigNumber(val) === true) {
    return new BN(val.toString(10))
  }
  if (isBN(val) === true) {
    return val
  }
  throw new Error(`unable to parse type &quot;${type}&quot;`)
}

// Parse N from type&lt;N&gt;
function parseTypeN(type) {
  let typesize = patterns.typeN.exec(type)
  return typesize ? parseInt(typesize[1], 10) : null
}

function parseTypeNArray(type) {
  let arraySize = patterns.typeNArray.exec(type)
  return arraySize ? parseInt(arraySize[1], 10) : null
}

function solidityPack(type, value, arraySize) {
  let size
  let num
  let {maxIntSize} = values
  let {zero, one} = values.solidity.pack
  let padAmount
  type = elementaryName(type)

  if (type === &apos;bytes&apos;) {
    if (removeLeadingZeroX(value).length % 2 !== 0) {
      throw new Error(&apos;Invalid bytes characters &apos; + value.length)
    }

    return value
  }

  if (type === &apos;string&apos;) {
    return utf8ToHex(value)
  }

  if (type === &apos;bool&apos;) {
    return value ? one : zero
  }

  if (type.startsWith(&apos;address&apos;) === true) {
    size = values.addressLength

    if (isAddress(value) === false) {
      throw new Error(`&quot;${value}&quot; is not a valid address`)
    }

    return leftPad(value.toLowerCase(), size)
  }

  size = parseTypeN(type)

  if (type.startsWith(&apos;bytes&apos;) === true) {
    if (size === undefined) {
      throw new Error(&apos;bytes[] not yet supported in solidity&apos;)
    }

    // must be 32 byte slices when in an array
    if (isNumber(arraySize) === true) {
      size = 32
    }

    if (size &lt; 1 || size &gt; 32 || size &lt; removeLeadingZeroX(value).length / 2) {
      throw new Error(`Invalid bytes${size} for ${value}`)
    }

    return rightPad(value, size * 2)
  }

  if (type.startsWith(&apos;uint&apos;) === true) {
    if (size % 8 || size &lt; 8 || size &gt; maxIntSize) {
      throw new Error(`invalid uint size: ${size}, max size: ${maxIntSize}`)
    }

    num = parseNumber(value)
    if (num.bitLength() &gt; size) {
      throw new Error(
        &apos;Supplied uint exceeds width: &apos; + size + &apos; vs &apos; + num.bitLength()
      )
    }

    if (num.lt(new BN(0)) === true) {
      throw new Error(&apos;Supplied uint &apos; + num.toString() + &apos; is negative&apos;)
    }

    // TODO: figure out these values
    padAmount = size / 8
    padAmount = padAmount * 2
    return size ? leftPad(num.toString(&apos;hex&apos;), padAmount) : num
  }

  if (type.startsWith(&apos;int&apos;) === true) {
    if (size % 8 || size &lt; 8 || size &gt; maxIntSize) {
      throw new Error(&apos;Invalid int&apos; + size + &apos; size&apos;)
    }

    num = parseNumber(value)
    if (num.bitLength() &gt; size) {
      throw new Error(
        &apos;Supplied int exceeds width: &apos; + size + &apos; vs &apos; + num.bitLength()
      )
    }

    if (num.lt(new BN(0)) === true) {
      return num.toTwos(size).toString(&apos;hex&apos;)
    }

    // TODO: figure out these values
    padAmount = size / 8
    padAmount = padAmount * 2
    return size ? leftPad(num.toString(&apos;hex&apos;), padAmount) : num
  }

  // FIXME: support all other types
  throw new Error(&apos;Unsupported or invalid type: &apos; + type)
}

function soliditySortArg(item) {
  let type
  let value
  let arraySize
  let hexArg

  if (isArray(item) === true) {
    throw new Error(
      `soliditySha3 doesn&apos;t accept Array type because ethereum web3 doesn&apos;t`
    )
  }

  // { t: &apos;&apos;, v: &apos;&apos;}
  // { type: &apos;&apos;, value: &apos;&apos;}
  if (
    typeof item === &apos;object&apos; &amp;&amp;
    (item.t !== undefined || item.type !== undefined) &amp;&amp;
    (item.v !== undefined || item.value !== undefined)
  ) {
    type = item.type || item.t
    value = item.value || item.v
  } else {
    type = toHex(item, true)
    value = toHex(item)

    if (type.startsWith(&apos;int&apos;) === false &amp;&amp; type.startsWith(&apos;uint&apos;) === false) {
      type = &apos;bytes&apos;
    }
  }

  if (
    (type.startsWith(&apos;int&apos;) === true || type.startsWith(&apos;uint&apos;) === true) &amp;&amp;
    typeof value === &apos;string&apos; &amp;&amp;
    patterns.zeroXNegative.test(value) === false
  ) {
    value = new BN(value)
  }

  // get the array size
  if (isArray(value) === true) {
    arraySize = parseTypeNArray(type)
    if (isNumber(arraySize) === true &amp;&amp; value.length !== arraySize) {
      let arr = JSON.stringify(value)
      throw new Error(`${type} is not matching the given array ${arr}`)
    } else {
      arraySize = value.length
    }
  }

  if (isArray(value) === true) {
    hexArg = value.map(item =&gt; {
      return removeLeadingZeroX(
        solidityPack(type, item, arraySize).toString(&apos;hex&apos;)
      )
    })
    return hexArg.join(&apos;&apos;)
  } else {
    hexArg = solidityPack(type, value, arraySize)
    return removeLeadingZeroX(hexArg.toString(&apos;hex&apos;))
  }
}

/**
 * Converts all the arguments into some other format then hashes it with sha3.
 * @param args captures all arguments
 * @return {string} [description]
 */
function soliditySha3() {
  return sha3(
    prependZeroX(
      Array.from(arguments)
        .map(soliditySortArg)
        .join(&apos;&apos;)
    )
  )
}

/**
 * Convert an Aion address to an Aion Checksum address.
 *
 * Rather than being all lower or uppercase letters are upper or lower based
 * on some critera.
 *
 * @param {string} val
 * @return {string}
 */
let toChecksumAddress = val =&gt; {
  if (accounts.isAccountAddress(val) === false) {
    // this differs from how ethereum web3 does it
    // ethereum web3 returns a blank string
    // we throw if it&apos;s invalid
    throw new Error(`Given address &quot;${val}&quot; is not a valid Aion address.`)
  }

  return accounts.createChecksumAddress(val)
}

/**
 * Convert hex string to number string
 * @param {string} val
 * @return {string}
 */
let hexToNumberString = val =&gt; toBN(val).toString(10)

/**
 * Convert hex string to javascript number
 * @param {string} val
 * @return {number}
 */
let hexToNumber = val =&gt; toBN(val).toNumber()

/**
 * Convert hex string to utf8 string
 * @param {string} val
 * @return {string}
 */
function hexToUtf8(val) {
  // it removes 000000 padding
  let op = removeLeadingZeroX(val)
    .replace(patterns.leadingHexZeroPadding, &apos;&apos;)
    .split(&apos;&apos;)
    .reverse()
    .join(&apos;&apos;)
    .replace(patterns.leadingHexZeroPadding, &apos;&apos;)
    .split(&apos;&apos;)
    .reverse()
    .join(&apos;&apos;)

  op = prependZeroX(op)
  op = hexToBytes(op)
    .map(item =&gt; String.fromCharCode(item))
    .join(&apos;&apos;)

  return utf8.decode(op)
}

function hexToAscii(val) {
  return hexToBytes(val)
    .map(item =&gt; String.fromCharCode(item))
    .join(&apos;&apos;)
}

function asciiToHex(val) {
  if (isEmpty(val) === true) {
    return copyString(values.hex.zero)
  }

  return prependZeroX(
    val
      .split(&apos;&apos;)
      .map(item =&gt; item.charCodeAt(0).toString(16))
      .join(&apos;&apos;)
  )
}

let toTwosComplement = val =&gt;
  prependZeroX(
    toBN(val)
      .toTwos(256)
      .toString(16, 64)
  )

function blake2b256(val) {
  if (
    val === undefined ||
    val === null ||
    // not having slice meaning it&apos;s not an array-like thing
    (typeof val !== &apos;string&apos; &amp;&amp;
      get(val, &apos;slice&apos;) === undefined &amp;&amp;
      isBN(val) === false)
  ) {
    throw new Error(`blake2b256 invalid value: &quot;${val}&quot;`)
  }

  let op

  if (typeof val === &apos;string&apos;) {
    // copy the string
    op = copyString(val)

    if (startsWithZeroX(op) === true) {
      // the user passed in a string like &apos;0xdccd2e7f400ab38e&apos;
      op = hexToBytes(op)
    } else {
      op = Buffer.from(op)
    }
  }

  if (isBN(val) === true) {
    op = Buffer.from(val.toString())
  }

  op = crypto.blake2b256(op)
  op = op.toString(&apos;hex&apos;)

  return `0x${op}`
}

module.exports = {
  // ethereum web3 implementations
  randomHex,
  _,
  BN,
  toBN,
  isBN,
  isBigNumber,
  isHex,
  isHexStrict,
  hexToBytes,
  bytesToHex,
  toHex,
  checkAddressChecksum,
  toChecksumAddress,
  utf8ToHex,
  isAddress,
  hexToNumberString,
  hexToNumber,
  numberToHex,
  hexToUtf8,
  hexToAscii,
  asciiToHex,
  padLeft,
  leftPad,
  padRight,
  rightPad,
  toTwosComplement,
  sha3,
  keccak256: sha3,
  soliditySha3,
  blake2b256
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
