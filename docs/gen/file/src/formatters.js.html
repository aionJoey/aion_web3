<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/formatters.js | aion-web3</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="web3-compatible api for working with aion"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="aion-web3"><meta property="twitter:description" content="web3-compatible api for working with aion"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/aionnetwork/aion_web3.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/formatters.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">let {isString, isNumber, isObject, isArray, isEmpty} = require(&apos;underscore&apos;)
let {isAccountAddress} = require(&apos;./lib/accounts&apos;)
let {prependZeroX, removeLeadingZeroX} = require(&apos;./lib/formats&apos;)
let {
  toBN,
  isHexStrict,
  numberToHex,
  isHex,
  utf8ToHex,
  hexToNumber,
  hexToUtf8,
  toChecksumAddress,
  sha3
} = require(&apos;./utils&apos;)
let Iban = require(&apos;./iban&apos;)

let outputBigNumberFormatter = val =&gt; toBN(val).toString(10)

let isPredefinedBlockNumber = val =&gt;
  val === &apos;latest&apos; || val === &apos;pending&apos; || val === &apos;earliest&apos;

function inputDefaultBlockNumberFormatter(val) {
  if (this &amp;&amp; (val === undefined || val === null)) {
    return this.defaultBlock
  }
  if (val === &apos;genesis&apos; || val === &apos;earliest&apos;) {
    return &apos;0x0&apos;
  }
  return inputBlockNumberFormatter(val)
}

function inputBlockNumberFormatter(val) {
  if (val === undefined) {
    return undefined
  } else if (isPredefinedBlockNumber(val)) {
    return val
  }

  if (isHexStrict(val) === true) {
    return isString(val) === true ? val.toLowerCase() : val
  }

  return numberToHex(val)
}

function txInputFormatter(options) {
  if (options.to) {
    // it might be contract creation
    options.to = inputAddressFormatter(options.to)
  }

  if (options.data &amp;&amp; options.input) {
    throw new Error(
      &apos;You can\&apos;t have &quot;data&quot; and &quot;input&quot; as properties of transactions at the same time, please use either &quot;data&quot; or &quot;input&quot; instead.&apos;
    )
  }

  if (!options.data &amp;&amp; options.input) {
    options.data = options.input
    delete options.input
  }

  if (options.data &amp;&amp; !isHex(options.data)) {
    throw new Error(&apos;The data field must be HEX encoded data.&apos;)
  }

  // allow both
  if (options.gas || options.gasLimit) {
    options.gas = options.gas || options.gasLimit
  }

  ;[&apos;gasPrice&apos;, &apos;gas&apos;, &apos;value&apos;, &apos;nonce&apos;]
    .filter(function(key) {
      return options[key] !== undefined
    })
    .forEach(function(key) {
      options[key] = numberToHex(options[key])
    })

  return options
}

function inputCallFormatter(options) {
  options = txInputFormatter(options)

  let from = options.from || (this ? this.defaultAccount : null)

  if (from) {
    options.from = inputAddressFormatter(from)
  }

  return options
}

function inputTransactionFormatter(options) {
  options = txInputFormatter(options)

  // check from, only if not number, or object
  if (!isNumber(options.from) &amp;&amp; !isObject(options.from)) {
    options.from = options.from || (this ? this.defaultAccount : null)

    if (!options.from &amp;&amp; !isNumber(options.from)) {
      throw new Error(&apos;The send transactions &quot;from&quot; field must be defined!&apos;)
    }

    options.from = inputAddressFormatter(options.from)
  }

  return options
}

function inputSignFormatter(data) {
  return isHexStrict(data) ? data : utf8ToHex(data)
}

function outputTransactionFormatter(tx) {
  if (tx.blockNumber !== null) tx.blockNumber = hexToNumber(tx.blockNumber)
  if (tx.transactionIndex !== null)
    tx.transactionIndex = hexToNumber(tx.transactionIndex)
  tx.nonce = hexToNumber(tx.nonce)
  tx.gas = hexToNumber(tx.gas)
  tx.gasPrice = outputBigNumberFormatter(tx.gasPrice)
  tx.value = outputBigNumberFormatter(tx.value)

  if (tx.to &amp;&amp; isAccountAddress(tx.to)) {
    // tx.to could be `0x0` or `null` while contract creation
    tx.to = toChecksumAddress(tx.to)
  } else {
    tx.to = null // set to `null` if invalid address
  }

  if (tx.from) {
    tx.from = toChecksumAddress(tx.from)
  }

  return tx
}

function outputTransactionReceiptFormatter(receipt) {
  if (typeof receipt !== &apos;object&apos;) {
    throw new Error(&apos;Received receipt is invalid: &apos; + receipt)
  }

  if (receipt.blockNumber !== null)
    receipt.blockNumber = hexToNumber(receipt.blockNumber)
  if (receipt.transactionIndex !== null)
    receipt.transactionIndex = hexToNumber(receipt.transactionIndex)
  receipt.cumulativeGasUsed = hexToNumber(receipt.cumulativeGasUsed)
  receipt.gasUsed = hexToNumber(receipt.gasUsed)

  if (isArray(receipt.logs)) {
    receipt.logs = receipt.logs.map(outputLogFormatter)
  }

  if (receipt.contractAddress) {
    receipt.contractAddress = toChecksumAddress(receipt.contractAddress)
  }

  if (typeof receipt.status !== &apos;undefined&apos;) {
    receipt.status = Boolean(parseInt(receipt.status))
  }

  return receipt
}

function outputBlockFormatter(block) {
  // transform to number
  block.gasLimit = hexToNumber(block.gasLimit)
  block.gasUsed = hexToNumber(block.gasUsed)
  block.size = hexToNumber(block.size)
  block.timestamp = hexToNumber(block.timestamp)
  if (block.number !== null) block.number = hexToNumber(block.number)

  if (block.difficulty)
    block.difficulty = outputBigNumberFormatter(block.difficulty)
  if (block.totalDifficulty)
    block.totalDifficulty = outputBigNumberFormatter(block.totalDifficulty)

  if (isArray(block.transactions)) {
    block.transactions.forEach(function(item) {
      if (!isString(item)) return outputTransactionFormatter(item)
    })
  }

  if (block.miner) block.miner = toChecksumAddress(block.miner)

  return block
}

function inputLogFormatter(options) {
  function toTopic(value) {
    if (value === null || typeof value === &apos;undefined&apos;) return null

    value = String(value)

    if (value.indexOf(&apos;0x&apos;) === 0) return value
    else return utf8ToHex(value)
  }

  // make sure topics, get converted to hex
  options.topics = options.topics || []
  options.topics = options.topics.map(function(topic) {
    return isArray(topic) ? topic.map(toTopic) : toTopic(topic)
  })

  if (isEmpty(options.address) === false) {
    if (isArray(options.address) === true) {
      options.address = options.address.map(function(addr) {
        return inputAddressFormatter(addr)
      })
    } else {
      options.address = inputAddressFormatter(options.address)
    }
  }

  return options
}

function outputLogFormatter(log) {
  // generate a custom log id
  if (
    typeof log.blockHash === &apos;string&apos; &amp;&amp;
    typeof log.transactionHash === &apos;string&apos; &amp;&amp;
    typeof log.logIndex === &apos;string&apos;
  ) {
    let shaId = sha3(
      log.blockHash.replace(&apos;0x&apos;, &apos;&apos;) +
        log.transactionHash.replace(&apos;0x&apos;, &apos;&apos;) +
        log.logIndex.replace(&apos;0x&apos;, &apos;&apos;)
    )
    log.id = &apos;log_&apos; + shaId.replace(&apos;0x&apos;, &apos;&apos;).substr(0, 8)
  } else if (!log.id) {
    log.id = null
  }

  if (log.blockNumber !== null) log.blockNumber = hexToNumber(log.blockNumber)
  if (log.transactionIndex !== null)
    log.transactionIndex = hexToNumber(log.transactionIndex)
  if (log.logIndex !== null) log.logIndex = hexToNumber(log.logIndex)

  if (log.address) {
    log.address = toChecksumAddress(log.address)
  }

  return log
}

function inputPostFormatter(post) {
  // post.payload = toHex(post.payload);

  if (post.ttl) post.ttl = numberToHex(post.ttl)
  if (post.workToProve) post.workToProve = numberToHex(post.workToProve)
  if (post.priority) post.priority = numberToHex(post.priority)

  // fallback
  if (!isArray(post.topics)) {
    post.topics = post.topics ? [post.topics] : []
  }

  // format the following options
  post.topics = post.topics.map(function(topic) {
    // convert only if not hex
    return topic.indexOf(&apos;0x&apos;) === 0 ? topic : utf8ToHex(topic)
  })

  return post
}

/**
 * Formats the output of a received post message
 *
 * @param {object} post
 * @returns {object}
 */
function outputPostFormatter(post) {
  post.expiry = hexToNumber(post.expiry)
  post.sent = hexToNumber(post.sent)
  post.ttl = hexToNumber(post.ttl)
  post.workProved = hexToNumber(post.workProved)
  // post.payloadRaw = post.payload;
  // post.payload = hexToAscii(post.payload);

  // if (isJson(post.payload)) {
  //     post.payload = JSON.parse(post.payload);
  // }

  // format the following options
  if (!post.topics) {
    post.topics = []
  }
  post.topics = post.topics.map(function(topic) {
    return hexToUtf8(topic)
  })

  return post
}

function inputAddressFormatter(ibanAddress) {
  let iban = new Iban(ibanAddress)
  if (iban.isValid() === true &amp;&amp; iban.isDirect() === true) {
    return iban.toAddress().toLowerCase()
  } else if (isAccountAddress(ibanAddress) === true) {
    return prependZeroX(removeLeadingZeroX(ibanAddress.toLowerCase()))
  }
  throw new Error(
    &apos;Provided ibanAddress &quot;&apos; +
      ibanAddress +
      &apos;&quot; is invalid, the capitalization checksum test failed, or its an indrect IBAN address which can\&apos;t be converted.&apos;
  )
}

function outputSyncingFormatter(result) {
  result.startingBlock = hexToNumber(result.startingBlock)
  result.currentBlock = hexToNumber(result.currentBlock)
  result.highestBlock = hexToNumber(result.highestBlock)
  if (result.knownStates) {
    result.knownStates = hexToNumber(result.knownStates)
    result.pulledStates = hexToNumber(result.pulledStates)
  }

  return result
}

module.exports = {
  outputBigNumberFormatter,
  isPredefinedBlockNumber,
  inputDefaultBlockNumberFormatter,
  inputBlockNumberFormatter,
  inputCallFormatter,
  inputTransactionFormatter,
  inputSignFormatter,
  outputTransactionFormatter,
  outputTransactionReceiptFormatter,
  outputBlockFormatter,
  inputLogFormatter,
  outputLogFormatter,
  inputPostFormatter,
  outputPostFormatter,
  inputAddressFormatter,
  outputSyncingFormatter
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
