<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/lib/formats.js | aion-web3</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="web3-compatible api for working with aion"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="aion-web3"><meta property="twitter:description" content="web3-compatible api for working with aion"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/aionnetwork/aion_web3.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/lib/formats.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">let randomHex = require(&apos;randomhex&apos;)
let numberToBn = require(&apos;number-to-bn&apos;)
let {Buffer} = require(&apos;safe-buffer&apos;)
let {isEmpty, isArray, isString, isNumber} = require(&apos;underscore&apos;)
let BN = require(&apos;bn.js&apos;)
let values = require(&apos;./values&apos;)
let patterns = require(&apos;./patterns&apos;)

let copyString = val =&gt; &apos;&apos; + val

/**
 * True if string starts with &apos;0x&apos;
 * @param {string} val
 * @return {boolean}
 */
let startsWithZeroX = val =&gt;
  isString(val) === true &amp;&amp; patterns.zeroX.test(val) === true

/**
 * Removes &apos;0x&apos; from a string
 * @private
 * @param {string} val
 * @return {string}checkAddressChecksum
 */
let removeLeadingZeroX = val =&gt;
  startsWithZeroX(val) === true ? val.replace(patterns.zeroX, &apos;&apos;) : val

/**
 * Put the 0x at the beginning of a string
 * @private
 * @param {string} val
 * @return {string}
 */
let prependZeroX = val =&gt;
  startsWithZeroX(val) === false ? values.zeroX + val : val

/**
 * Strips &apos;0x&apos; and turns it into a Buffer
 * @param {string} val [description]
 * @return {buffer} [description]
 */
let hexToBuffer = val =&gt; toBuffer(val)

/**
 * Random Buffer of a size
 * @param {number} size
 * @return {buffer}
 */
let randomHexBuffer = (size = values.hex.randomHexSize) =&gt;
  hexToBuffer(randomHex(size))

/**
 * True if a string is hex
 * @param {string} val
 * @return {boolean}
 */
let isHex = val =&gt; isString(val) === true &amp;&amp; patterns.hex.test(val) === true

/**
 * True if two buffers have the same length and bytes
 * @param {buffer} buf1
 * @param {buffer} buf2
 * @return {boolean}
 */
function equalBuffers(buf1, buf2) {
  if (buf1.length !== buf2.length) {
    return false
  }

  return buf1.every((byte, index) =&gt; {
    return (buf2[index] = byte)
  })
}

/**
 * Gracefully try to convert anything into a buffer
 * @param {object} val anything
 * @param {string} encoding hex, base64, utf8
 * @return {buffer}
 */
function toBuffer(val, encoding) {
  // buffer or array
  if (isArray(val) === true || Buffer.isBuffer(val) === true) {
    return Buffer.from(val)
  }

  if (isNaN(val) === false || isNumber(val) === true || BN.isBN(val) === true) {
    return Buffer.from(numberToBn(val).toString(&apos;hex&apos;), &apos;hex&apos;)
  }

  // string
  if (isString(val) === true &amp;&amp; isEmpty(encoding) === true) {
    // hex
    if (isHex(val) === true) {
      return Buffer.from(removeLeadingZeroX(val), &apos;hex&apos;)
    }

    // base64
    if (patterns.base64.test(val) === true) {
      return Buffer.from(val, &apos;base64&apos;)
    }
  }

  // anything else
  return Buffer.from(val, encoding)
}

let isBuffer = val =&gt; Buffer.isBuffer(val)

function toNumber(val) {
  if (typeof val === &apos;number&apos;) {
    return val
  }

  if (isHex(val) === true) {
    return new BN(removeLeadingZeroX(val), &apos;hex&apos;).toNumber()
  }

  if (BN.isBN(val) === true) {
    return val.toNumber()
  }

  throw new Error(`unknown format &quot;${typeof val}&quot; ${val}`)
}

module.exports = {
  copyString,
  startsWithZeroX,
  removeLeadingZeroX,
  prependZeroX,
  hexToBuffer,
  randomHexBuffer,
  Buffer,
  equalBuffers,
  toBuffer,
  isBuffer,
  isHex,
  toNumber
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
