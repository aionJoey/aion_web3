<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/abi.js | aion-web3</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="web3-compatible api for working with aion"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="aion-web3"><meta property="twitter:description" content="web3-compatible api for working with aion"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/aionnetwork/aion_web3.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/abi.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">let padStart = require(&apos;lodash/padStart&apos;)
let padEnd = require(&apos;lodash/padEnd&apos;)
let {isString, isObject, isEmpty, each, flatten} = require(&apos;underscore&apos;)
let {
  copyString,
  prependZeroX,
  toBuffer,
  removeLeadingZeroX
} = require(&apos;./lib/formats&apos;)
let {keccak256} = require(&apos;./lib/crypto&apos;)
let solidity = require(&apos;./lib/solidity&apos;)
let values = require(&apos;./lib/values&apos;)

/**
 * Shared between function and event signatures. Hashes the function name
 * @param {string} val
 * @return {string} hash
 */
function fnHashBuffer(val) {
  let op

  if (isString(val) === true) {
    op = copyString(val)
  }

  if (isObject(val) === true) {
    op = copyString(val.name)

    if (isEmpty(val.inputs) === false) {
      op += &apos;(&apos; + val.inputs.map(item =&gt; item.type).join(&apos;,&apos;) + &apos;)&apos;
    }
  }

  return keccak256(op)
}

let hexStringPadLeft = val =&gt;
  padStart(val, values.solidity.typeStringLength, &apos;0&apos;)

let hexStringPadRight = val =&gt;
  padEnd(val, values.solidity.typeStringLength, &apos;0&apos;)

let dimensionSorter = (a, b) =&gt; a.index &gt; b.index

function encodeAbiString(val) {
  let length = hexStringPadLeft(val.length.toString(16))
  let stringValue = hexStringPadRight(toBuffer(val, &apos;utf8&apos;).toString(&apos;hex&apos;))
  return `${length}${stringValue}`
}

function encodeAbiBoolean(val) {
  return copyString(
    val === true ? values.solidity.boolean.one : values.solidity.boolean.zero
  )
}

function encodeAbiNumber(val) {
  return hexStringPadLeft(toBuffer(val).toString(&apos;hex&apos;))
}

function encodeAbiAddress(val) {
  return removeLeadingZeroX(val)
}

let abiTypeEncoders = {
  string: encodeAbiString,
  bytes: encodeAbiString,
  bool: encodeAbiBoolean,
  uint: encodeAbiNumber,
  int: encodeAbiNumber,
  fixed: encodeAbiNumber,
  ufixed: encodeAbiNumber,
  address: encodeAbiAddress
}

/**
 * Encode event to its ABI signature
 * @param {string|object} val
 * @return {string}
 */
function encodeEventSignature(val) {
  return prependZeroX(fnHashBuffer(val).toString(&apos;hex&apos;))
}

/**
 * Encode function to its ABI signature
 * @param {string|object} val
 * @return {string}
 */
function encodeFunctionSignature(val) {
  return prependZeroX(
    fnHashBuffer(val)
      .slice(0, solidity.types.function.length)
      .toString(&apos;hex&apos;)
  )
}

/**
 * Encode a list of parameters to ABI signature
 * @param {array} types
 * @param {array} params
 * @return {string}
 */
function encodeParameters(types, params) {
  // parse all the types
  let parsedTypes = types.map(solidity.parseType)
  let op = []

  // if any are dynamic we must use offsets
  // let needsOffsets = parsedTypes.some(item =&gt; item.dynamic === true)

  each(params, (typeValues, index) =&gt; {
    let {baseType, array, dynamic /*, dimensions*/} = parsedTypes[index]
    let valueParser = abiTypeEncoders[baseType]
    // dimensions = dimensions.sort(dimensionSorter)

    if (array === true) {
      let typeOp = []

      if (dynamic === true) {
        let offset = encodeAbiNumber(
          toBuffer(flatten(op).join(&apos;&apos;), &apos;hex&apos;).length
        )
        // console.log(&apos;2 offset&apos;, offset)
        typeOp.push(offset)
      }

      let length = encodeAbiNumber(typeValues.length)
      typeOp.push(length)

      each(typeValues, item =&gt; {
        let parsedItem = valueParser(item)
        typeOp.push(parsedItem)
      })

      return op.push(typeOp)
    }

    op.push(valueParser(typeValues))
  })

  return prependZeroX(flatten(op).join(&apos;&apos;))
}

/**
 * Encode parameter to ABI signature
 * @param {string} type
 * @param {string|array|object} param
 * @return {string}
 */
function encodeParameter(type, param) {
  return encodeParameters([type], [param])
}

/**
 * Encode function call to ABI signature
 * @param {object} jsonInterface
 * @param {array} params
 * @return {string}
 */
function encodeFunctionCall(jsonInterface, params) {}

/**
 * Decode a parameter value from it&apos;s ABI encoding
 * @param {string} type
 * @param {string} val
 * @return {string}
 */
function decodeParameter(type, val) {}

/**
 * Decode the parameters hex into an array of decoded values
 * @param {array} types
 * @param {string} val
 * @return {array} [description]
 */
function decodeParameters(types, val) {}

/**
 * ABI decoded log data
 * @param {array} inputs
 * @param {string} val
 * @param {array} topics
 * @return {array}
 */
function decodeLog(inputs, val, topics) {}

module.exports = {
  encodeFunctionSignature,
  encodeEventSignature,
  encodeParameter,
  encodeParameters,
  encodeFunctionCall,
  decodeParameter,
  decodeParameters,
  decodeLog
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
